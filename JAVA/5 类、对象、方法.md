# 构造方法重载
```Java
import lombok.Builder
@Builder
class Person{
	private String name;
	private int age;
	private String job;
	private String sex;
}

Person myperson = new Person.builder(“张三”,24)// job 和 sex 会被设为null 
```

- RetentionPolicy.class
- RetentionPolicy.runtime
- RetentionPolicy.

# 禁用类的构造方法，而是提供一个（或多个）instance，这样的类被称为单例类和多例类
```Java
// 多例类
class Singleton{
	private Singleton(){
	
	}
	
	private static Singleton instance = new Singleton();// 在加载类的时候生成
}


public static void main(String args[]){
	Singleton mySingleton = new Singleton.getInstance();
	System.out.println(mySingleton);
	Singleton mySingleton1 = new Singleton.getInstance();
	System.out.println(mySingleton1);
	// 输出的结果是一样的
} 

```
```Java
// 单例类
class Singleton{
	private Singleton(){
	
	}
	
	private static Singleton instance = null;// 在需要用到的时候才生成
	public static Singleton getInstance(){
		if (instance = null){
			instance = new Singleton() 
		}	
	}
}


public static void main(String args[]){
	Singleton mySingleton = new Singleton.getInstance();
	System.out.println(mySingleton);
	Singleton mySingleton1 = new Singleton.getInstance();
	System.out.println(mySingleton1);
	// 输出的结果是一样的
} 
```
- **enum** 实际上是一种多例类
# 接口的使用
```Java
interface Enemy{
	void takeDamage(int amount);
	boolean isAlive();
}

class Zombie implements Enemy{
	private int health = 100;
	@override
	public void takeDamage(int amount){
		this.health -= amount;
	}
	public Boolean isAlive(){
		…// logic
	}
}

// 解耦后的设计 (Good)
public class Sword {
    private int damage = 10;

    // 核心：方法参数是 "Enemy" 接口！
    public void attack(Enemy target) {
        
        // 我不管你是什么类，我只知道你“能” (can-do) 接受伤害
        if (target.isAlive()) {
            target.takeDamage(this.damage);
        }
    }
}

```
# 垃圾回收
## 强制进行垃圾回收
```Java
System.gc()

```