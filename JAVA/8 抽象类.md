```Java
abstract class Person{
	int age;
	int name;
	
	Person(String name, int age){
		this.name=name;
		this.age=age;
	}	
	
	abstract void f();
	
	void g(){// 模版方法
		// …
		f();// 在子类中f()将会被实现，也叫做延迟实现。对于不同的子类，f方法的操作会不一样
		//…
	}
};
```

## 多态 晚绑定
```Java
public class polyDemo{
	public static void main(String[] args){
		Shape shape = new Circle();
		shape.draw();// 输出的是Circle Draw，但是Ctrl点击draw的时候会定位到Shape的draw。因为这个shape具体是什么要在运行时才能被知道
		// 这样实现了代码的复用（晚绑定）
		// 因此，Circle.draw的访问权限只能被扩大，不能被缩小，否则有可能编译的时候没问题，运行时访问不到
		System.out.println(shape.i);// 输出的是10，因为多态是仅仅针对**方法**的，对于成员变量没有多态这一说
	}
}

abstract class Shape{
	public i = 10;
	void draw(){
		System.out.println(“Shape Draw”);
	}
}

class Circle{
	public i = 100;
	void draw(){
		System.out.println(“Circle Draw”);
	}
}

class Triangle{
	void draw(){
		System.out.println(“Triangle Draw”);
	}
}
```




